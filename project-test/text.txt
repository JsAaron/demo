
学习笔记。。。积累！！
合抱之木,生于毫末。九层之台,起于累土。千里之行,始于足下
  博客园 :: 首页 :: 博问 :: 闪存 :: 新随笔 :: 联系 :: 订阅 订阅 :: 管理 ::		
  85 随笔 :: 1 文章 :: 80 评论 :: 0 引用
<	2015年8月	>
日	一	二	三	四	五	六
26	27	28	29	30	31	1
2	3	4	5	6	7	8
9	10	11	12	13	14	15
16	17	18	19	20	21	22
23	24	25	26	27	28	29
30	31	1	2	3	4	5
公告
IT新闻:
昵称：gaojun
园龄：6年4个月
粉丝：181
关注：0
搜索
 
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
node.js(2)
详解(2)
远程连接(1)
最大值(1)
最小值(1)
nodejs(1)
oracle 10.2.0数据库。(1)
pl/sql developer(1)
process.nextTick(1)
SVN(1)
更多
随笔分类
C++(6)
Firefox浏览器(8)
JQuery(2)
Linux(12)
node.js(3)
Web后台(4)
Web前端(21)
杂项(3)
随笔档案
2014年12月 (5)
2014年3月 (1)
2014年1月 (2)
2013年12月 (1)
2013年11月 (1)
2013年10月 (9)
2013年6月 (1)
2013年5月 (2)
2013年4月 (1)
2013年3月 (2)
2013年1月 (1)
2012年12月 (4)
2012年11月 (3)
2012年8月 (8)
2012年7月 (1)
2012年6月 (3)
2012年5月 (4)
2012年4月 (1)
2010年9月 (2)
2010年8月 (1)
2010年5月 (1)
2010年4月 (4)
2010年3月 (2)
2010年1月 (1)
2009年12月 (2)
2009年8月 (1)
2009年7月 (2)
2009年6月 (5)
2009年5月 (11)
2009年4月 (3)
相册
我(1)
最新评论
1. Re:C++模板学习
顶顶顶顶！！！！！
车间生产管理工具 
--yizong001
2. Re:Linux上Oracle 11g安装步骤图解
mark一下，试试
--wgh130505
3. Re:UML建模教程
不错的文档，很基础。学习了
--IT邦德
4. Re:Linux上Oracle 11g安装步骤图解
非常不错，谢谢分享
--Neo.chen
阅读排行榜
1. C++模板学习(100213)
2. Linux上Oracle 11g安装步骤图解(87594)
3. Linux LVM硬盘管理及LVM扩容(80636)
4. 18种常见室内花卉的功效 (转自网络)(65597)
5. 查看LINUX进程内存占用情况(57532)
评论排行榜
1. C++模板学习(18)
2. Linux上Oracle 11g安装步骤图解(11)
3. 孙鑫视频VC++深入详解学习笔记(10)
4. Linux LVM硬盘管理及LVM扩容(9)
5. 借助网盘搭建SVN服务器(6)
推荐排行榜
1. C++模板学习(33)
2. Linux LVM硬盘管理及LVM扩容(10)
3. Linux上Oracle 11g安装步骤图解(8)
4. 孙鑫视频VC++深入详解学习笔记(8)
5. JS面向对象的程序设计(8)
Node.js文件系统、路径的操作详解
 

 

Node.js文件系统、路径的操作函数
目录

Node.js文件系统、路径的操作函数

1、读取文件readFile函数

2、写文件

3、以追加方式写文件

4、打开文件

5、读文件，读取打开的文件内容到缓冲区中；

6、写文件，将缓冲区内数据写入使用fs.open打开的文件

7、刷新缓存区;

8、创建目录;

9、读取目录;

10、查看文件与目录的信息;

11、查看文件与目录的是否存在

12、修改文件访问时间与修改时间

13、修改文件或目录的操作权限

14、移动/重命名文件或目录

15、删除空目录

16、监视文件

17、取消监视文件

18、文件流

19、创建读取流

20、创建写入流

21、管道pipe实现流读写

22、路径解析，得到规范化的路径格式

23、路径结合、合并，路径最后不会带目录分隔符

24、获取绝对路径

25、获取相对路径

26、path.dirname(p)

27、path.basename(path, [ext])

28、path.extname(path)

29、path.sep 属性

30、path.delimiter属性

参考：

 

 

将Node.js的文件系统、文件流及路径操作API详细的学习了一下，代码都是测试过的，也许很简单，但为了打好基础，还是要有点一丝不苟的精神，从中我也更深入理解异步回调事件机制，希望对你有用……

//公共引用

1.        var fs = require('fs'),

2.            path = require('path');

1、读取文件readFile函数

//readFile(filename,[options],callback);

/**

 * filename, 必选参数，文件名

 * [options],可选参数，可指定flag（文件操作选项，如r+ 读写；w+ 读写，文件不存在则创建）及encoding属性

 * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据

 */

1.        fs.readFile(__dirname + '/test.txt', {flag: 'r+', encoding: 'utf8'}, function (err, data) {

2.            if(err) {

3.                console.error(err);

4.                return;

5.            }

6.            console.log(data);

7.        });

2、写文件

// fs.writeFile(filename,data,[options],callback);

var w_data = '这是一段通过fs.writeFile函数写入的内容；\r\n';

var w_data = new Buffer(w_data);

 

/**

 * filename, 必选参数，文件名

 * data, 写入的数据，可以字符或一个Buffer对象

 * [options],flag,mode(权限),encoding

 * callback 读取文件后的回调函数，参数默认第一个err,第二个data 数据

 */

1.        fs.writeFile(__dirname + '/test.txt', w_data, {flag: 'a'}, function (err) {

2.            if(err) {

3.                console.error(err);

4.            } else {

5.                console.log('写入成功');

6.            }

7.        });

 

3、以追加方式写文件

// fs.appendFile(filename,data,[options],callback);

1.        fs.appendFile(__dirname + '/test.txt', '使用fs.appendFile追加文件内容', function () {

2.            console.log('追加内容完成');

3.        });

 

4、打开文件

// fs.open(filename, flags, [mode], callback);

/**

 * filename, 必选参数，文件名

 * flags, 操作标识，如"r",读方式打开

 * [mode],权限，如777，表示任何用户读写可执行

 * callback 打开文件后回调函数，参数默认第一个err,第二个fd为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄

 */

1.        fs.open(__dirname + '/test.txt', 'r', '0666', function (err, fd) {

2.            console.log(fd);

3.        });

 

5、读文件，读取打开的文件内容到缓冲区中；

// fs.read(fd, buffer, offset, length, position, callback);

/**

 * fd, 使用fs.open打开成功后返回的文件描述符

 * buffer, 一个Buffer对象，v8引擎分配的一段内存

 * offset, 整数，向缓存区中写入时的初始位置，以字节为单位

 * length, 整数，读取文件的长度

 * position, 整数，读取文件初始位置；文件大小以字节为单位

 * callback(err, bytesRead, buffer), 读取执行完成后回调函数，bytesRead实际读取字节数，被读取的缓存区对象

 */

 

1.        fs.open(__dirname + '/test.txt', 'r', function (err, fd) {

2.            if(err) {

3.                console.error(err);

4.                return;

5.            } else {

6.                var buffer = new Buffer(255);

7.                console.log(buffer.length);

8.                //每一个汉字utf8编码是3个字节，英文是1个字节

9.                fs.read(fd, buffer, 0, 9, 3, function (err, bytesRead, buffer) {

10.                 if(err) {

11.                     throw err;

12.                 } else {

13.                     console.log(bytesRead);

14.                     console.log(buffer.slice(0, bytesRead).toString());

15.                     //读取完后，再使用fd读取时，基点是基于上次读取位置计算；

16.                     fs.read(fd, buffer, 0, 9, null, function (err, bytesRead, buffer) {

17.                         console.log(bytesRead);

18.                         console.log(buffer.slice(0, bytesRead).toString());

19.                     });

20.                 }

21.             });

22.         }

23.     });

 

6、写文件，将缓冲区内数据写入使用fs.open打开的文件

//fs.write(fd, buffer, offset, length, position, callback);

/**

 * fd, 使用fs.open打开成功后返回的文件描述符

 * buffer, 一个Buffer对象，v8引擎分配的一段内存

 * offset, 整数，从缓存区中读取时的初始位置，以字节为单位

 * length, 整数，从缓存区中读取数据的字节数

 * position, 整数，写入文件初始位置；

 * callback(err, written, buffer), 写入操作执行完成后回调函数，written实际写入字节数，buffer被读取的缓存区对象

 */

 

1.        fs.open(__dirname + '/test.txt', 'a', function (err, fd) {

2.            if(err) {

3.                console.error(err);

4.                return;

5.            } else {

6.                var buffer = new Buffer('写入文件数据内容');

7.                //写入'入文件'三个字

8.                fs.write(fd, buffer, 3, 9, 12, function (err, written, buffer) {

9.                    if(err) {

10.                     console.log('写入文件失败');

11.                     console.error(err);

12.                     return;

13.                 } else {

14.                     console.log(buffer.toString());

15.                     fs.write(fd, buffer, 12, 9, null, function (err, written, buffer) {

16.                         console.log(buffer.toString());

17.                     })

18.                 }

19.             });

20.         }

21.     });

 

7、刷新缓存区;

// 使用fs.write写入文件时，操作系统是将数据读到内存，再把数据写入到文件中，当数据读完时并不代表数据已经写完，因为有一部分还可能在内在缓冲区内。

// 因此可以使用fs.fsync方法将内存中数据写入文件；--刷新内存缓冲区；

//fs.fsync(fd, [callback])

/**

 * fd, 使用fs.open打开成功后返回的文件描述符

 * [callback(err, written, buffer)], 写入操作执行完成后回调函数，written实际写入字节数，buffer被读取的缓存区对象

 */

1.        fs.open(__dirname + '/test.txt', 'a', function (err, fd) {

2.            if(err)

3.                throw err;

4.            var buffer = new Buffer('我爱nodejs编程');

5.         

6.            fs.write(fd, buffer, 0, 9, 0, function (err, written, buffer) {

7.                console.log(written.toString());

8.                fs.write(fd, buffer, 9, buffer.length - 9, null, function (err, written) {

9.                    console.log(written.toString());

10.                 fs.fsync(fd);

11.                 fs.close(fd);

12.             })

13.         });

14.     });

 

8、创建目录;

//使用fs.mkdir创建目录

//fs.mkdir(path, [mode], callback);

/**

 * path, 被创建目录的完整路径及目录名；

 * [mode], 目录权限，默认0777

 * [callback(err)], 创建完目录回调函数,err错误对象

 */

1.        fs.mkdir(__dirname + '/fsDir', function (err) {

2.            if(err)

3.                throw err;

4.         

5.            console.log('创建目录成功')

6.        });

 

9、读取目录;

//使用fs.readdir读取目录，重点其回调函数中files对象

//fs.readdir(path, callback);

/**

 * path, 要读取目录的完整路径及目录名；

 * [callback(err, files)], 读完目录回调函数；err错误对象，files数组，存放读取到的目录中的所有文件名

 */

1.        fs.readdir(__dirname + '/fsDir/', function (err, files) {

2.            if(err) {

3.                console.error(err);

4.                return;

5.            } else {

6.                files.forEach(function (file) {

7.                    var filePath = path.normalize(__dirname + '/fsDir/' + file);

8.                    fs.stat(filePath, function (err, stat) {

9.                        if(stat.isFile()) {

10.                         console.log(filePath + ' is: ' + 'file');

11.                     }

12.                     if(stat.isDirectory()) {

13.                         console.log(filePath + ' is: ' + 'dir');

14.                     }

15.                 });

16.             });

17.             for (var i = 0; i < files.length; i++) {

18.                 //使用闭包无法保证读取文件的顺序与数组中保存的致

19.                 (function () {

20.                     var filePath = path.normalize(__dirname + '/fsDir/' + files[i]);

21.                     fs.stat(filePath, function (err, stat) {

22.                         if(stat.isFile()) {

23.                             console.log(filePath + ' is: ' + 'file');

24.                         }

25.                         if(stat.isDirectory()) {

26.                             console.log(filePath + ' is: ' + 'dir');

27.                         }

28.                     });

29.                 })();

30.             }

31.         }

32.     });

 

10、查看文件与目录的信息;

//fs.stat(path, callback);

//fs.lstat(path, callback); //查看符号链接文件

/**

 * path, 要查看目录/文件的完整路径及名；

 * [callback(err, stats)], 操作完成回调函数；err错误对象，stat fs.Stat一个对象实例，提供如:isFile, isDirectory,isBlockDevice等方法及size,ctime,mtime等属性

 */

//实例，查看fs.readdir

 

11、查看文件与目录的是否存在

//fs.exists(path, callback);

/**

 * path, 要查看目录/文件的完整路径及名；

 * [callback(exists)], 操作完成回调函数；exists true存在，false表示不存在

 */

1.        fs.exists(__dirname + '/te', function (exists) {

2.            var retTxt = exists ? retTxt = '文件存在' : '文件不存在';

3.            console.log(retTxt);

4.        });

 

12、修改文件访问时间与修改时间

//fs.utimes(path, atime, mtime, callback);

/**

 * path, 要查看目录/文件的完整路径及名；

 * atime, 新的访问时间

 * ctime, 新的修改时间

 * [callback(err)], 操作完成回调函数；err操作失败对象

 */

 

1.        fs.utimes(__dirname + '/test.txt', new Date(), new Date(), function (err) {

2.            if(err) {

3.                console.error(err);

4.                return;

5.            }

6.            fs.stat(__dirname + '/test.txt', function (err, stat) {

7.                console.log('访问时间: ' + stat.atime.toString() + '; \n修改时间：' + stat.mtime);

8.                console.log(stat.mode);

9.            })

10.     });

 

13、修改文件或目录的操作权限

//fs.utimes(path, mode, callback);

/**

 * path, 要查看目录/文件的完整路径及名；

 * mode, 指定权限，如：0666 8进制，权限：所有用户可读、写，

 * [callback(err)], 操作完成回调函数；err操作失败对象

 */

 

1.        fs.chmod(__dirname + '/fsDir', 0666, function (err) {

2.            if(err) {

3.                console.error(err);

4.                return;

5.            }

6.            console.log('修改权限成功')

7.        });

 

14、移动/重命名文件或目录

//fs.rename(oldPath, newPath, callback);

/**

 * oldPath, 原目录/文件的完整路径及名；

 * newPath, 新目录/文件的完整路径及名；如果新路径与原路径相同，而只文件名不同，则是重命名

 * [callback(err)], 操作完成回调函数；err操作失败对象

 */

 

1.        fs.rename(__dirname + '/test', __dirname + '/fsDir', function (err) {

2.            if(err) {

3.                console.error(err);

4.                return;

5.            }

6.            console.log('重命名成功')

7.        });

15、删除空目录

//fs.rmdir(path, callback);

/**

 * path, 目录的完整路径及目录名；

 * [callback(err)], 操作完成回调函数；err操作失败对象

 */

1.        fs.rmdir(__dirname + '/test', function (err) {

2.            fs.mkdir(__dirname + '/test', 0666, function (err) {

3.                console.log('创建test目录');

4.            });

5.         

6.            if(err) {

7.                console.log('删除空目录失败，可能原因：1、目录不存在，2、目录不为空')

8.                console.error(err);

9.                return;

10.         }

11.      

12.         console.log('删除空目录成功!');

13.     });

 

16、监视文件

//对文件进行监视，并且在监视到文件被修改时执行处理

//fs.watchFile(filename, [options], listener);

/**

 * filename, 完整路径及文件名；

 * [options], persistent true表示持续监视，不退出程序；interval 单位毫秒，表示每隔多少毫秒监视一次文件

 * listener, 文件发生变化时回调，有两个参数：curr为一个fs.Stat对象，被修改后文件，prev,一个fs.Stat对象，表示修改前对象

 */

1.        fs.watchFile(__dirname + '/test.txt', {interval: 20}, function (curr, prev) {

2.            if(Date.parse(prev.ctime) == 0) {

3.                console.log('文件被创建!');

4.            } else if(Date.parse(curr.ctime) == 0) {

5.                console.log('文件被删除!')

6.            } else if(Date.parse(curr.mtime) != Date.parse(prev.mtime)) {

7.                console.log('文件有修改');

8.            }

9.        });

10.      

11.     fs.watchFile(__dirname + '/test.txt', function (curr, prev) {

12.         console.log('这是第二个watch,监视到文件有修改');

13.     });

 

17、取消监视文件

//取消对文件进行监视

//fs.unwatchFile(filename, [listener]);

/**

 * filename, 完整路径及文件名；

 * [listener], 要取消的监听器事件，如果不指定，则取消所有监听处理事件

 */

1.        var listener = function (curr, prev) {

2.            console.log('我是监视函数')

3.        }

4.        fs.unwatchFile(__dirname + '/test.txt', listener);

 

16、监视文件或目录

// 对文件或目录进行监视，并且在监视到修改时执行处理；

// fs.watch返回一个fs.FSWatcher对象，拥有一个close方法，用于停止watch操作；

// 当fs.watch有文件变化时，会触发fs.FSWatcher对象的change(err, filename)事件，err错误对象，filename发生变化的文件名

// fs.watch(filename, [options], [listener]);

/**

 * filename, 完整路径及文件名或目录名；

 * [listener(event, filename], 监听器事件，有两个参数：event 为rename表示指定的文件或目录中有重命名、删除或移动操作或change表示有修改，filename表示发生变化的文件路径

 */

 

1.        var fsWatcher = fs.watch(__dirname + '/test', function (event, filename) {

2.            //console.log(event)

3.        });

4.         

5.        //console.log(fsWatcher instanceof FSWatcher);

6.         

7.        fsWatcher.on('change', function (event, filename) {

8.            console.log(filename + ' 发生变化')

9.        });

10.      

11.     //30秒后关闭监视

12.     setTimeout(function () {

13.         console.log('关闭')

14.         fsWatcher.close(function (err) {

15.             if(err) {

16.                 console.error(err)

17.             }

18.             console.log('关闭watch')

19.         });

20.     }, 30000);

 

18、文件流

/*

 * 流，在应用程序中表示一组有序的、有起点有终点的字节数据的传输手段；

 * Node.js中实现了stream.Readable/stream.Writeable接口的对象进行流数据读写；以上接口都继承自EventEmitter类，因此在读/写流不同状态时，触发不同事件；

 * 关于流读取：Node.js不断将文件一小块内容读入缓冲区，再从缓冲区中读取内容；

 * 关于流写入：Node.js不断将流数据写入内在缓冲区，待缓冲区满后再将缓冲区写入到文件中；重复上面操作直到要写入内容写写完；

 * readFile、read、writeFile、write都是将整个文件放入内存而再操作，而则是文件一部分数据一部分数据操作；

 *

 * -----------------------流读取-------------------------------------

 * 读取数据对象：

 * fs.ReadStream 读取文件

 * http.IncomingMessage 客户端请求或服务器端响应

 * net.Socket    Socket端口对象

 * child.stdout  子进程标准输出

 * child.stdin   子进程标准入

 * process.stdin 用于创建进程标准输入流

 * Gzip、Deflate、DeflateRaw   数据压缩

 *

 * 触发事件：

 * readable  数据可读时

 * data      数据读取后

 * end       数据读取完成时

 * error     数据读取错误时

 * close     关闭流对象时

 *

 * 读取数据的对象操作方法：

 * read      读取数据方法

 * setEncoding   设置读取数据的编码

 * pause     通知对象众目停止触发data事件

 * resume    通知对象恢复触发data事件

 * pipe      设置数据通道，将读入流数据接入写入流；

 * unpipe    取消通道

 * unshift   当流数据绑定一个解析器时，此方法取消解析器

 *

 * ------------------------流写入-------------------------------------

 * 写数据对象：

 * fs.WriteStream           写入文件对象

 * http.clientRequest       写入HTTP客户端请求数据

 * http.ServerResponse      写入HTTP服务器端响应数据

 * net.Socket               读写TCP流或UNIX流，需要connection事件传递给用户

 * child.stdout             子进程标准输出

 * child.stdin              子进程标准入

 * Gzip、Deflate、DeflateRaw  数据压缩

 *

 * 写入数据触发事件：

 * drain            当write方法返回false时，表示缓存区中已经输出到目标对象中，可以继续写入数据到缓存区

 * finish           当end方法调用，全部数据写入完成

 * pipe             当用于读取数据的对象的pipe方法被调用时

 * unpipe           当unpipe方法被调用

 * error            当发生错误

 *

 * 写入数据方法：

 * write            用于写入数据

 * end              结束写入，之后再写入会报错；

 */

 

19、创建读取流

//fs.createReadStream(path, [options])

/**

 * path 文件路径

 * [options] flags:指定文件操作，默认'r',读操作；encoding,指定读取流编码；autoClose, 是否读取完成后自动关闭，默认true；start指定文件开始读取位置；end指定文件开始读结束位置

 */

1.        var rs = fs.createReadStream(__dirname + '/test.txt', {start: 0, end: 2});

2.         

3.        //open是ReadStream对象中表示文件打开时事件，

4.        rs.on('open', function (fd) {

5.            console.log('开始读取文件');

6.        });

7.         

8.        rs.on('data', function (data) {

9.            console.log(data.toString());

10.     });

11.      

12.     rs.on('end', function () {

13.         console.log('读取文件结束')

14.     });

15.      

16.     rs.on('close', function () {

17.         console.log('文件关闭');

18.     });

19.      

20.     rs.on('error', function (err) {

21.         console.error(err);

22.     });

23.      

24.     //暂停和回复文件读取；

25.      

26.     rs.on('open', function () {

27.         console.log('开始读取文件');

28.     });

29.      

30.     rs.pause();

31.      

32.     rs.on('data', function (data) {

33.         console.log(data.toString());

34.     });

35.      

36.     setTimeout(function () {

37.         rs.resume();

38.     }, 2000);

20、创建写入流

//fs.createWriteStream(path, [options])

/**

 * path 文件路径

 * [options] flags:指定文件操作，默认'w',；encoding,指定读取流编码；start指定写入文件的位置

 */

 

/* ws.write(chunk, [encoding], [callback]);

 * chunk,  可以为Buffer对象或一个字符串，要写入的数据

 * [encoding],  编码

 * [callback],  写入后回调

 */

 

/* ws.end([chunk], [encoding], [callback]);

 * [chunk],  要写入的数据

 * [encoding],  编码

 * [callback],  写入后回调

 */

 

1.        var ws = fs.createWriteStream(__dirname + '/test.txt', {start: 0});

2.         

3.        var buffer = new Buffer('我也喜欢你');

4.         

5.         

6.        ws.write(buffer, 'utf8', function (err, buffer) {

7.            console.log(arguments);

8.            console.log('写入完成，回调函数没有参数')

9.        });

10.      

11.     //最后再写入的内容

12.     ws.end('再见');

13.      

14.     //使用流完成复制文件操作

15.     var rs = fs.createReadStream(__dirname + '/test.txt')

16.     var ws = fs.createWriteStream(__dirname + '/test/test.txt');

17.     rs.on('data', function (data) {

18.         ws.write(data)

19.     });

20.      

21.     ws.on('open', function (fd) {

22.         console.log('要写入的数据文件已经打开，文件描述符是： ' + fd);

23.     });

24.      

25.     rs.on('end', function () {

26.         console.log('文件读取完成');

27.      

28.         ws.end('完成', function () {

29.             console.log('文件全部写入完成')

30.         });

31.     });

 

//关于WriteStream对象的write方法返回一个布尔类型，当缓存区中数据全部写满时，返回false;

//表示缓存区写满，并将立即输出到目标对象中

 

//第一个例子

1.        var ws = fs.createWriteStream(__dirname + '/test/test.txt');

2.        for (var i = 0; i < 10000; i++) {

3.            var w_flag = ws.write(i.toString());

4.            //当缓存区写满时，输出false

5.            console.log(w_flag);

6.        }

 

//第二个例子

1.        var ws = fs.createWriteStream(__dirname + '/test/untiyou.mp3');

2.        var rs = fs.createReadStream(__dirname + '/test/Until You.mp3');

3.        rs.on('data', function (data) {

4.            var flag = ws.write(data);

5.            console.log(flag);

6.        });

7.         

8.        //系统缓存区数据已经全部输出触发drain事件

9.        ws.on('drain', function () {

10.         console.log('系统缓存区数据已经全部输出。')

11.     });

 

21、管道pipe实现流读写

//rs.pipe(destination, [options]);

/**

 * destination 必须一个可写入流数据对象

 * [opations] end 默认为true，表示读取完成立即关闭文件；

 */

 

1.        var rs = fs.createReadStream(__dirname + '/test/Until You.mp3');

2.        var ws = fs.createWriteStream(__dirname + '/test/untiyou.mp3');

3.        rs.pipe(ws);

4.         

5.        rs.on('data', function (data) {

6.            console.log('数据可读')

7.        });

8.         

9.        rs.on('end', function () {

10.         console.log('文件读取完成');

11.         //ws.end('再见')

12.     });

 

//---------------------路径操作-------------------------

22、路径解析，得到规范化的路径格式

//对window系统，目录分隔为'\', 对于UNIX系统，分隔符为'/'，针对'..'返回上一级；/与\\都被统一转换

//path.normalize(p);

 

1.        var myPath = path.normalize(__dirname + '/test/a//b//../c/utilyou.mp3');

2.        console.log(myPath); //windows: E:\workspace\NodeJS\app\fs\test\a\c\utilyou.mp3

 

23、路径结合、合并，路径最后不会带目录分隔符

//path.join([path1],[path2]..[pathn]);

/**

 * [path1] 路径或表示目录的字符，

 */

 

1.        var path1 = 'path1',

2.            path2 = 'path2//pp\\',

3.            path3 = '../path3'

4.         

5.        var myPath = path.join(path1, path2, path3);

6.        console.log(myPath); //path1\path2\path3

24、获取绝对路径

//path.resolve(path1, [path2]..[pathn]);

//以应用程序为起点，根据参数字符串解析出一个绝对路径

/**

 * path 必须至少一个路径字符串值

 * [pathn] 可选路径字符串

 */

1.        var myPath = path.resolve('path1', 'path2', 'a/b\\c/');

2.        console.log(myPath);//E:\workspace\NodeJS\path1\path2\a\b\c

 

25、获取相对路径

//path.relative(from, to);

//获取两路径之间的相对关系

/**

 * from 当前路径，并且方法返回值是基于from指定到to的相对路径

 * to   到哪路径，

 */

1.        var from = 'c:\\from\\a\\',

2.            to = 'c:/test/b';

3.        var _path = path.relative(from, to);

4.        console.log(_path); //..\..\test\b; 表示从from到to的相对路径

 

26、path.dirname(p)

// 获取路径中目录名

1.        var myPath = path.dirname(__dirname + '/test/util you.mp3');

2.        console.log(myPath);

 

27、path.basename(path, [ext])

// 获取路径中文件名,后缀是可选的，如果加，请使用'.ext'方式来匹配，则返回值中不包括后缀名；

1.        var myPath = path.basename(__dirname + '/test/util you.mp3', '.mp3');

2.        console.log(myPath);

 

28、path.extname(path)

获取路径中的扩展名，如果没有'.'，则返回空

 

29、path.sep属性

返回操作系统中文件分隔符； window是'\\', Unix是'/'

 

30、path.delimiter属性

返回操作系统中目录分隔符，如window是';', Unix中是':'

 

 

参考：

《Node.js权威指南》之在Node.js中操作文件系统

Email:gaojun_le@163.com

分类: Web后台, node.js
标签: 详解, node.js, 路径解析, 文件操作
绿色通道： 好文要顶 关注我 收藏该文与我联系 
gaojun
关注 - 0
粉丝 - 181
+加关注
0 0
(请您对文章做出评价)
« 上一篇：Node.js的循环与异步问题
» 下一篇：Node.js的process.nextTick(callback)理解
posted on 2014-12-12 13:04 gaojun 阅读(1547) 评论(0) 编辑 收藏
刷新评论刷新页面返回顶部
发表评论
昵称：

评论内容：引用 粗体 链接 缩进 代码 图片

 注销 订阅评论

[Ctrl+Enter快捷键提交]

【推荐】50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库
【推荐】融云即时通讯云－专注为 App 开发者提供IM云服务

最新IT新闻:
· 被曝红米Note 2屏幕和摄像头偷梁换柱后：小米换图，删帖，发声明！
· 这位少年，12岁开始炒股编代码，13岁开了第一家公司
· John Horton Conway的游戏人生
· 用了一年时间，关掉全部线下店面，才开始懂得同城物流该怎么做
· 富士康要在印度开银行
» 更多新闻...

最新知识库文章:
· 关于软件开发，你老板不知道的7件事
· 关于烂代码的那些事（中）
· 关于烂代码的那些事（上）
· 作为码农，我们为什么要写作
· 今天你写了自动化测试吗
» 更多知识库文章...
Powered by: 
博客园 
Copyright © gaojun